<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Torneo FIFA 5B 2025/26</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Cinzel:wght@600;700;900&family=Inter:wght@400;500;600;800&display=swap"
        rel="stylesheet">
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üèÜ</text></svg>">
    <style>
        :root {
            /* Zinc Palette (Dark Professional) */
            --bg-body: #09090b;
            --bg-card: #18181b;
            --bg-subtle: #27272a;
            --border-color: #3f3f46;
            --text-primary: #f4f4f5;
            --text-secondary: #a1a1aa;
            --text-muted: #52525b;
            --accent-gold: #fbbf24;
            --accent-glow: rgba(251, 191, 36, 0.15);
            --success-color: #34d399;
            --danger-color: #f87171;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-body);
            color: var(--text-primary);
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            padding-bottom: 2rem;
        }

        /* Ambient Dynamic Background */
        body::before {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle at center, rgba(16, 185, 129, 0.03) 0%, transparent 40%),
                radial-gradient(circle at 80% 20%, rgba(251, 191, 36, 0.03) 0%, transparent 30%),
                radial-gradient(circle at 20% 80%, rgba(59, 130, 246, 0.03) 0%, transparent 30%);
            animation: moveMist 60s linear infinite;
            z-index: -2;
            pointer-events: none;
        }

        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.05'/%3E%3C/svg%3E");
            z-index: -1;
            opacity: 0.03;
            pointer-events: none;
        }

        @keyframes moveMist {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 3rem 1.5rem;
            position: relative;
            z-index: 1;
        }

        /* Animations */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes textShine {
            0% {
                background-position: 0% 50%;
                filter: drop-shadow(0 0 10px rgba(251, 191, 36, 0.2));
            }

            50% {
                background-position: 100% 50%;
                filter: drop-shadow(0 0 25px rgba(251, 191, 36, 0.6));
            }

            100% {
                background-position: 0% 50%;
                filter: drop-shadow(0 0 10px rgba(251, 191, 36, 0.2));
            }
        }

        @keyframes borderPulse {
            0% {
                box-shadow: 0 10px 30px -10px rgba(0, 0, 0, 0.5);
                border-color: rgba(251, 191, 36, 0.3);
            }

            50% {
                box-shadow: 0 10px 40px -5px rgba(251, 191, 36, 0.2);
                border-color: rgba(251, 191, 36, 0.6);
            }

            100% {
                box-shadow: 0 10px 30px -10px rgba(0, 0, 0, 0.5);
                border-color: rgba(251, 191, 36, 0.3);
            }
        }

        .fade-in-el {
            opacity: 0;
            animation: fadeInUp 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }

        /* Header */
        header {
            margin-bottom: 3rem;
            text-align: center;
        }

        /* Epic Title Text */
        .epic-title {
            font-family: 'Cinzel', serif;
            font-size: 3.5rem;
            line-height: 1;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            margin: 0 auto 1.5rem;
            text-align: center;
            background: linear-gradient(to right, #bf953f, #fcf6ba, #b38728, #fbf5b7, #aa771c, #bf953f);
            background-size: 200% auto;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: textShine 5s linear infinite, fadeInUp 1s ease-out forwards;
            position: relative;
            display: block;
            transition: transform 0.3s;
        }

        .epic-title:hover {
            transform: scale(1.02);
            filter: drop-shadow(0 2px 0px rgba(0, 0, 0, 0.8)) drop-shadow(0 0 40px rgba(251, 191, 36, 0.8));
        }

        @media (min-width: 768px) {
            .epic-title {
                font-size: 4.5rem;
            }
        }

        .subtitle-badge {
            display: inline-block;
            padding: 0.5rem 1.5rem;
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 50px;
            color: var(--accent-gold);
            font-size: 0.85rem;
            font-weight: 700;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.1);
            animation-delay: 0.2s;
        }

        /* Teams Section */
        .teams-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 1.5rem;
            margin-bottom: 4rem;
        }

        .team-card {
            background: rgba(24, 24, 27, 0.4);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            text-align: center;
            transition: all 0.3s;
        }

        .team-card:hover {
            transform: translateY(-5px);
            border-color: var(--accent-gold);
            background: rgba(24, 24, 27, 0.8);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .team-card-logo {
            width: 80px;
            height: 80px;
            object-fit: contain;
            margin-bottom: 1rem;
            filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.3));
            transition: transform 0.4s;
        }

        .team-card:hover .team-card-logo {
            transform: scale(1.15) rotate(5deg);
        }

        .player-name {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .team-name {
            font-size: 0.85rem;
            color: var(--accent-gold);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        /* Sections */
        h2 {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        section {
            margin-bottom: 5rem;
        }

        /* Tables */
        .glass-panel {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            box-shadow: 0 20px 40px -10px rgba(0, 0, 0, 0.5);
            animation: borderPulse 4s infinite ease-in-out;
            overflow: hidden;
        }

        .table-scroll {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            border-radius: 0 0 16px 16px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 1rem;
        }

        th {
            background: rgba(39, 39, 42, 0.95);
            color: var(--accent-gold);
            padding: 1.5rem 1rem;
            border-bottom: 2px solid var(--accent-gold);
            position: sticky;
            top: 0;
            z-index: 20;
            text-align: center;
            font-size: 0.8rem;
            text-transform: uppercase;
        }

        /* Alignment Fixes for Table */
        th:first-child,
        td:first-child {
            text-align: left;
            padding-left: 2rem;
            min-width: 200px;
            /* Ensure space for names */
        }

        td {
            padding: 1.5rem 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            text-align: center;
            color: var(--text-secondary);
            transition: all 0.3s;
        }

        td:first-child {
            color: var(--text-primary);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        tr:hover {
            background: rgba(251, 191, 36, 0.05) !important;
            backdrop-filter: blur(5px);
        }

        /* Sticky Column */
        th.sticky-col,
        td.sticky-col {
            position: sticky;
            right: 0;
            background: var(--bg-card);
            border-left: 1px solid var(--border-color);
            z-index: 25;
        }

        th.sticky-col {
            background: rgba(39, 39, 42, 0.95);
        }

        tr:hover td.sticky-col {
            background: var(--bg-subtle);
        }

        .points-val {
            font-weight: 900;
            color: var(--accent-gold);
            font-size: 1.25rem;
            text-shadow: 0 0 15px rgba(251, 191, 36, 0.2);
        }

        /* Logos */
        .team-logo-small {
            width: 32px;
            height: 32px;
            object-fit: contain;
            filter: drop-shadow(0 2px 5px rgba(0, 0, 0, 0.5));
        }

        /* Matches Grouping */
        .match-day-group {
            margin-bottom: 3rem;
        }

        .match-day-title {
            font-size: 1rem;
            color: var(--accent-gold);
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 700;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
            display: inline-block;
        }

        .matches-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
        }

        .match-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.2rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .match-card:hover {
            transform: translateY(-5px) scale(1.02);
            border-color: var(--accent-gold);
            box-shadow: 0 15px 40px -10px rgba(251, 191, 36, 0.2);
            z-index: 2;
        }

        .match-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: var(--bg-subtle);
            transition: all 0.3s;
        }

        .match-card:hover::before {
            background: var(--accent-gold);
            width: 5px;
            box-shadow: 0 0 15px var(--accent-gold);
        }

        .match-meta {
            display: flex;
            justify-content: space-between;
            margin-bottom: 1rem;
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            font-weight: 600;
        }

        .match-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .match-row.winner {
            color: var(--text-primary);
            font-weight: 700;
        }

        .score-box {
            background: var(--bg-subtle);
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
            min-width: 2rem;
            text-align: center;
            font-weight: 600;
            border: 1px solid var(--border-color);
        }

        .match-status {
            font-size: 0.7rem;
            padding: 4px 8px;
            border-radius: 20px;
            border: 1px solid var(--border-color);
        }

        .play-status {
            background: rgba(52, 211, 153, 0.1);
            color: var(--success-color);
            border-color: rgba(52, 211, 153, 0.2);
        }

        .status-upcoming {
            background: rgba(251, 191, 36, 0.1);
            color: var(--accent-gold);
            border-color: rgba(251, 191, 36, 0.2);
        }

        /* Stats */
        .stats-ticker {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 3rem;
        }

        .stat-box {
            background: rgba(24, 24, 27, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 16px;
            padding: 1.5rem;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            transition: all 0.3s;
        }

        .stat-box:hover {
            transform: translateY(-5px);
            border-color: var(--accent-gold);
        }

        .stat-label {
            color: var(--accent-gold);
            font-size: 0.8rem;
            text-transform: uppercase;
            margin-bottom: 1rem;
            font-weight: 700;
        }

        .stat-team-logo {
            width: 60px;
            height: 60px;
            margin-bottom: 0.5rem;
            transition: transform 0.5s;
            object-fit: contain;
        }

        .stat-box:hover .stat-team-logo {
            transform: scale(1.15) rotate(5deg);
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--text-primary);
        }

        .stat-sub {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        footer {
            margin-top: 3rem;
            padding-bottom: 2rem;
            text-align: center;
            color: var(--text-muted);
            font-size: 0.8rem;
            border-top: 1px solid var(--border-color);
            padding-top: 2rem;
        }

        @media (max-width: 640px) {
            .container {
                padding: 2rem 1rem;
            }

            .epic-title {
                font-size: 2.2rem;
                letter-spacing: 0.1em;
            }

            .subtitle-badge {
                font-size: 0.75rem;
                padding: 0.4rem 1rem;
            }

            .matches-grid {
                grid-template-columns: 1fr;
            }

            th,
            td {
                padding: 1rem 0.5rem;
                font-size: 0.9rem;
            }

            th:first-child,
            td:first-child {
                padding-left: 1rem;
                min-width: 150px;
            }

            .team-logo-small {
                width: 24px;
                height: 24px;
            }
        }

        /* Bracket Structure */
        .bracket-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            margin: 4rem 0;
            padding: 2rem;
            background: radial-gradient(circle, rgba(251, 191, 36, 0.05) 0%, transparent 70%);
            border-radius: 20px;
            overflow-x: auto;
        }

        .bracket-round {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            gap: 2rem;
        }

        .bracket-round-title {
            text-align: center;
            color: var(--accent-gold);
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 1rem;
            font-weight: 700;
        }

        .bracket-match {
            background: rgba(24, 24, 27, 0.8);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.8rem;
            width: 200px;
            position: relative;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .bracket-match:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.2);
            transform: scale(1.02);
        }

        .bracket-match.final-match {
            width: 240px;
            border-color: var(--accent-gold);
            background: linear-gradient(135deg, rgba(24, 24, 27, 0.9) 0%, rgba(50, 40, 10, 0.4) 100%);
        }

        .bracket-match.final-match .bracket-team {
            font-size: 1rem;
        }

        /* Connector Lines */
        .bracket-round:not(:last-child) .bracket-match::after {
            content: '';
            position: absolute;
            right: -2rem;
            top: 50%;
            width: 2rem;
            height: 2px;
            background: var(--border-color);
        }

        /* Specific connector logic would be complex with pure CSS, 
           simulating simpler flow for now or using SVG lines if needed. 
           For this "Legendary" feel, clean cards are better than messy lines. */

        .bracket-team {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.3rem 0;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .bracket-team.winner {
            color: var(--accent-gold);
            font-weight: 800;
            text-shadow: 0 0 5px rgba(251, 191, 36, 0.4);
        }

        .bracket-team-name {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 130px;
        }

        .bracket-score {
            font-weight: 700;
            background: var(--bg-subtle);
            padding: 0.1rem 0.4rem;
            border-radius: 4px;
            font-size: 0.8rem;
            min-width: 1.5rem;
            text-align: center;
        }

        .bracket-team.winner .bracket-score {
            background: rgba(251, 191, 36, 0.2);
            color: var(--accent-gold);
        }

        .champion-crown {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            filter: drop-shadow(0 0 10px rgba(251, 191, 36, 0.8));
            animation: bounce 2s infinite;
        }

        @keyframes bounce {

            0%,
            20%,
            50%,
            80%,
            100% {
                transform: translateX(-50%) translateY(0);
            }

            40% {
                transform: translateX(-50%) translateY(-10px);
            }

            60% {
                transform: translateX(-50%) translateY(-5px);
            }
        }
    </style>
</head>

<body>

    <canvas id="particle-canvas"
        style="position:fixed; top:0; left:0; width:100%; height:100%; z-index:-1; pointer-events:none;"></canvas>
    <div class="container">
        <header>
            <h1 class="epic-title fade-in-el">ULTIMO TORNEO FIFA</h1>
            <div class="subtitle-badge fade-in-el">
                5B Informatica 2025/2026
            </div>
        </header>

        <!-- LEGENDARY BRACKET AREA -->
        <div id="bracket-section" style="display:none;">
            <h2
                style="justify-content:center; text-align:center; color:var(--accent-gold); text-shadow: 0 0 10px rgba(251,191,36,0.3);">
                üåü FASE FINALE - THE LEGENDS üåü
            </h2>
            <div id="bracket-container" class="bracket-container fade-in-el">
                <!-- JS Injected Tree -->
            </div>
        </div>

        <section>
            <h2>Classifica</h2>
            <div class="glass-panel">
                <div class="table-scroll">
                    <table>
                        <thead>
                            <tr>
                                <th title="Squadra partecipanti">Squadra</th>
                                <th title="Giornate Disputate">G</th>
                                <th title="Vittorie (nei 90')">V</th>
                                <th title="Vittorie ai Rigori">V(R)</th>
                                <th title="Sconfitte ai Rigori">S(R)</th>
                                <th title="Sconfitte (nei 90')">S</th>
                                <th title="Gol Fatti">GF</th>
                                <th title="Gol Subiti">GS</th>
                                <th title="Differenza Reti">DR</th>
                                <th class="sticky-col" title="Punti Totali">Punti</th>
                            </tr>
                        </thead>
                        <tbody id="standings-body">
                            <!-- JS Injected -->
                        </tbody>
                    </table>
                </div>
            </div>
        </section>

        <div id="stats-area" class="stats-ticker">
            <!-- Stats -->
        </div>

        <section>
            <h2>Squadre e Giocatori</h2>
            <div class="teams-grid" id="teams-container">
                <!-- JS Injected -->
            </div>
        </section>

        <section id="professori-section" style="display:none">
            <h2>SFIDE SPECIALI</h2>
            <div id="professori-container" class="matches-grid">
                <!-- JS Injected -->
            </div>
        </section>

        <section>
            <h2>Calendario</h2>
            <div id="matches-container">
                <!-- JS Injected with grouping -->
            </div>
        </section>



        <footer>
            <p id="last-update">Aggiornato: --</p>
        </footer>
    </div>

    <script>
        // --- CONFIG & ASSETS ---
        // Mappa dei loghi per le squadre, associa nome squadra al file immagine
        const logoMap = {
            "Real Madrid": "assets/logos/real_madrid.png",
            "PSG": "assets/logos/psg.png",
            "Man City": "assets/logos/man_city_v2.png",
            "Bayern": "assets/logos/bayern.png",
            "Inter": "assets/logos/inter_v2.png",
            "Arsenal": "assets/logos/arsenal.png",
            "Barcellona": "assets/logos/barcellona.png",
            "Juventus": "assets/logos/juventus.png",
            "Juve": "assets/logos/juventus.png"
        };

        // Funzione per ottenere il percorso del logo
        function getLogo(teamName) {
            // Cerca se il nome della squadra contiene una delle chiavi nella mappa
            for (const key in logoMap) {
                if (teamName.includes(key)) return logoMap[key]; // Restituisce il logo se trovato
            }
            return ""; // Restituisce stringa vuota se non trova nulla
        }

        // Cache degli elementi DOM per evitare di cercarli ogni volta (ottimizzazione)
        const domCache = {
            standingsBody: document.getElementById('standings-body'),
            matchesContainer: document.getElementById('matches-container'),
            professoriSection: document.getElementById('professori-section'),
            professoriContainer: document.getElementById('professori-container'),
            teamsContainer: document.getElementById('teams-container'),
            statsArea: document.getElementById('stats-area'),
            lastUpdate: document.getElementById('last-update'),
            bracketSection: document.getElementById('bracket-section'),
            bracketContainer: document.getElementById('bracket-container')
        };

        // --- MAIN LOGIC ---
        // Funzione principale che scarica i dati
        async function fetchData() {
            try {
                // Crea un timestamp per evitare che il browser usi dati vecchi (cache busting)
                const t = new Date().getTime();

                // Scarica classifica e partite in parallelo per fare prima
                const [standingsRes, matchesRes] = await Promise.all([
                    fetch('classifica.json?t=' + t),
                    fetch('matches.json?t=' + t)
                ]);

                // Controlla se i file esistono, altrimenti ferma tutto
                if (!standingsRes.ok || !matchesRes.ok) throw new Error("File missing");

                // Converte i dati scaricati in formato leggibile (JSON)
                const standingsData = await standingsRes.json();
                const matchesData = await matchesRes.json();

                // Disegna la classifica sulla pagina
                renderStandings(standingsData.classifica);

                // Unisce partite normali e playoff in un'unica lista
                const allMatches = [...(matchesData.matches || []), ...(matchesData.playoffs || [])];
                // Disegna le partite del calendario
                renderMatches(allMatches);

                // Se ci sono playoff, disegna il tabellone
                if (matchesData.playoffs && matchesData.playoffs.length > 0) {
                    renderBracket(matchesData.playoffs, standingsData.classifica);
                    domCache.bracketSection.style.display = 'block';
                } else {
                    domCache.bracketSection.style.display = 'none';
                }

                // Se ci sono partite speciali (Professori), le disegna
                if (matchesData.professori && matchesData.professori.length > 0) {
                    renderSpecials(matchesData.professori);
                }

                // Aggiorna la scritta dell'ultimo aggiornamento in fondo alla pagina
                domCache.lastUpdate.textContent = 'Ultimo aggiornamento: ' + (standingsData.ultimo_aggiornamento || 'N/A');

                // Calcola e mostra le statistiche (miglior attacco, ecc.)
                calculateStats(standingsData.classifica);

                // Disegna la lista delle squadre e giocatori
                renderTeams(standingsData.classifica);

            } catch (e) {
                console.error("Dati non disponibili:", e);
                // User feedback
                if (domCache.lastUpdate) {
                    domCache.lastUpdate.innerHTML = "<span style='color:var(--danger-color)'>Errore caricamento dati. Riprova pi√π tardi.</span>";
                }
            }
        }

        function getShortName(fullName) {
            if (!fullName) return "TBD";
            if (fullName.includes('(')) {
                return fullName.split('(')[0].trim(); // Restituisce solo il nome del giocatore
            }
            return fullName;
        }

        // Render Legendary Bracket
        function renderBracket(playoffs, ranking) {
            const container = domCache.bracketContainer;
            container.innerHTML = '';

            // Find matches by ID
            const qf1 = playoffs.find(m => m.id === "QF1") || { squadra_a: "3¬∞ Class", squadra_b: "6¬∞ Class" };
            const qf2 = playoffs.find(m => m.id === "QF2") || { squadra_a: "4¬∞ Class", squadra_b: "5¬∞ Class" };
            const sf1 = playoffs.find(m => m.id === "SF1") || { squadra_a: "1¬∞ Class", squadra_b: "Vincente QF1" };
            const sf2 = playoffs.find(m => m.id === "SF2") || { squadra_a: "2¬∞ Class", squadra_b: "Vincente QF2" };
            const final = playoffs.find(m => m.id === "FINAL") || { squadra_a: "Vincente SF1", squadra_b: "Vincente SF2" };

            // Helper to build match HTML
            const buildMatchHtml = (match, isFinal = false) => {
                const winner = getWinner(match);
                const s_a = match.gol_a !== null ? match.gol_a : '-';
                const s_b = match.gol_b !== null ? match.gol_b : '-';

                // Determine winner formatting
                const classA = winner === match.squadra_a ? 'winner' : '';
                const classB = winner === match.squadra_b ? 'winner' : '';

                // Logos
                const logoA = getLogo(match.squadra_a);
                const logoB = getLogo(match.squadra_b);

                const crown = isFinal && winner ? '<div class="champion-crown">üëë</div>' : '';

                return `
                    <div class="bracket-match ${isFinal ? 'final-match' : ''}">
                        ${crown}
                        <div class="bracket-team ${classA}">
                            <div class="bracket-team-name">
                                ${logoA ? `<img src="${logoA}" style="width:20px;height:20px;margin-right:5px">` : ''}
                                ${getShortName(match.squadra_a)}
                            </div>
                            <span class="bracket-score">${s_a}</span>
                        </div>
                        <div class="bracket-team ${classB}">
                            <div class="bracket-team-name">
                                ${logoB ? `<img src="${logoB}" style="width:20px;height:20px;margin-right:5px">` : ''}
                                ${getShortName(match.squadra_b)}
                            </div>
                            <span class="bracket-score">${s_b}</span>
                        </div>
                    </div>
                `;
            };

            // Structure: 3 Columns (Quarters, Semis, Final)
            // But logic says: QF1 leads to SF1, QF2 leads to SF2.

            // Col 1: Quarters
            const colQF = document.createElement('div');
            colQF.className = 'bracket-round';
            colQF.innerHTML = `<div class="bracket-round-title">Quarti</div>
                               ${buildMatchHtml(qf1)}
                               ${buildMatchHtml(qf2)}`;

            // Col 2: Semis
            const colSF = document.createElement('div');
            colSF.className = 'bracket-round';
            // SF1 is Top Bracket side? 1st vs Winner QF1. 
            // SF2 is Bottom Bracket side? 2nd vs Winner QF2.
            // Visually align SF1 with QF1 and SF2 with QF2 is standard, assuming QF1 feeds SF1.
            // Wait, logic in py: 1st vs Winner QF1 (QF1 was 3v6). 
            colSF.innerHTML = `<div class="bracket-round-title">Semifinali</div>
                               ${buildMatchHtml(sf1)}
                               ${buildMatchHtml(sf2)}`;

            // Col 3: Final
            const colFinal = document.createElement('div');
            colFinal.className = 'bracket-round';
            colFinal.style.justifyContent = 'center'; // Center the single final
            colFinal.innerHTML = `<div class="bracket-round-title">Finalissima</div>
                                  ${buildMatchHtml(final, true)}`;

            container.appendChild(colQF);
            container.appendChild(colSF);
            container.appendChild(colFinal);
        }

        function getWinner(m) {
            if (!m || !m.risultato) return null;
            if (m.risultato === '90') {
                if (parseInt(m.gol_a) > parseInt(m.gol_b)) return m.squadra_a;
                if (parseInt(m.gol_b) > parseInt(m.gol_a)) return m.squadra_b;
            }
            if (m.risultato === 'rigori_a') return m.squadra_a;
            if (m.risultato === 'rigori_b') return m.squadra_b;
            return null;
        }

        // Calcola le statistiche dai dati della classifica
        function calculateStats(ranking) {
            // Se non ci sono dati, non fa nulla
            if (!ranking || ranking.length === 0) return;

            // Trova chi ha fatto pi√π gol (Miglior Attacco)
            const bestAttack = [...ranking].sort((a, b) => b.gol_fatti - a.gol_fatti)[0];
            // Trova chi ha subito meno gol (Miglior Difesa)
            const bestDefense = [...ranking].sort((a, b) => a.gol_subiti - b.gol_subiti)[0];
            // Trova la capolista (primo in classifica)
            const topTeam = ranking[0];

            // Inserisce l'HTML delle statistiche nella pagina
            domCache.statsArea.innerHTML = `
                <div class="stat-box fade-in-el" style="animation-delay: 0.1s">
                    <div class="stat-label">Miglior Attacco</div>
                    ${getLogo(bestAttack.squadra) ? `<img src="${getLogo(bestAttack.squadra)}" class="stat-team-logo" alt="">` : ''}
                    <div class="stat-value">${bestAttack.gol_fatti}</div>
                    <div class="stat-sub">Gol Fatti (${bestAttack.squadra.split('(')[0]})</div>
                </div>
                <div class="stat-box fade-in-el" style="animation-delay: 0.2s">
                     <div class="stat-label">Miglior Difesa</div>
                    ${getLogo(bestDefense.squadra) ? `<img src="${getLogo(bestDefense.squadra)}" class="stat-team-logo" alt="">` : ''}
                    <div class="stat-value">${bestDefense.gol_subiti}</div>
                    <div class="stat-sub">Gol Subiti (${bestDefense.squadra.split('(')[0]})</div>
                </div>
                 <div class="stat-box fade-in-el" style="animation-delay: 0.3s">
                     <div class="stat-label">Capolista</div>
                    ${getLogo(topTeam.squadra) ? `<img src="${getLogo(topTeam.squadra)}" class="stat-team-logo" alt="">` : ''}
                    <div class="stat-value">${topTeam.punti}</div>
                    <div class="stat-sub">Punti (${topTeam.squadra.split('(')[0]})</div>
                </div>
            `;
        }

        // Disegna le card delle squadre
        function renderTeams(data) {
            if (!domCache.teamsContainer) return;

            // Pulisce il contenitore
            domCache.teamsContainer.innerHTML = '';
            // Usa un fragment per aggiungere tutto in un colpo solo (pi√π veloce)
            const fragment = document.createDocumentFragment();

            data.forEach((team, idx) => {
                // Crea il contenitore della card
                const card = document.createElement('div');
                card.className = 'team-card fade-in-el';
                // Aggiunge un ritardo all'animazione per l'effetto cascata
                card.style.animationDelay = (idx * 0.1) + 's';

                const logo = getLogo(team.squadra);

                // Estrae il nome del giocatore e della squadra dalla stringa "Nome (Squadra)"
                let player = team.squadra;
                let club = "FC Club";

                if (team.squadra.includes('(')) {
                    const parts = team.squadra.split('(');
                    player = parts[0].trim(); // Nome giocatore
                    club = parts[1].replace(')', '').trim(); // Nome squadra
                } else {
                    club = team.squadra;
                }

                // Genera l'HTML interno della card
                card.innerHTML = `
                    ${logo ? `<img src="${logo}" class="team-card-logo" alt="${club}">` : ''}
                    <div class="player-name">${player}</div>
                    <div class="team-name">${club}</div>
                    <div style="margin-top:1rem; font-size:0.8rem; color:var(--text-muted)">
                         ${team.punti} Punti
                    </div>
                 `;

                // Aggiunge la card al fragment
                fragment.appendChild(card);
            });

            // Aggiunge tutto il fragment alla pagina in una volta sola
            domCache.teamsContainer.appendChild(fragment);
        }

        // Disegna la tabella della classifica
        function renderStandings(data) {
            // Pulisce la tabella
            domCache.standingsBody.innerHTML = '';
            const fragment = document.createDocumentFragment();

            data.forEach((team, index) => {
                const tr = document.createElement('tr');
                tr.className = 'fade-in-el';
                tr.style.animationDelay = `${index * 0.05}s`;

                // Calcola il colore della differenza reti (verde, rosso o grigio)
                const diffClass = team.differenza_reti > 0 ? 'diff-pos' : (team.differenza_reti < 0 ? 'diff-neg' : 'diff-neu');
                const diffSign = team.differenza_reti > 0 ? '+' : '';
                const logo = getLogo(team.squadra);

                // Assegna la corona al primo posto
                let rankContent = `<span class="rank-num">${index + 1}</span>`;
                if (index === 0) rankContent = `<span class="rank-num">üëë</span>`;

                // Riempie la riga della tabella con i dati
                tr.innerHTML = `
                    <td>
                        <div style="display:flex; align-items:center; gap:10px;">
                            ${rankContent}
                            ${logo ? `<img src="${logo}" class="team-logo-small" alt="">` : ''}
                            <span>${team.squadra}</span>
                        </div>
                    </td>
                    <td>${team.giornate}</td>
                    <td>${team.vittorie || 0}</td>
                    <td>${team.vittorie_rig || 0}</td>
                    <td>${team.sconfitte_rig || 0}</td>
                    <td>${team.sconfitte || 0}</td>
                    <td>${team.gol_fatti}</td>
                    <td>${team.gol_subiti}</td>
                    <td class="${diffClass}">${diffSign}${team.differenza_reti}</td>
                    <td class="sticky-col points-val">${team.punti}</td>
                `;
                fragment.appendChild(tr);
            });

            // Aggiunge tutte le righe alla tabella
            domCache.standingsBody.appendChild(fragment);
        }

        // Disegna le partite speciali (es. Professori)
        function renderSpecials(matches) {
            if (!domCache.professoriContainer || !matches || matches.length === 0) return;

            // Mostra la sezione che di default √® nascosta
            domCache.professoriSection.style.display = 'block';
            domCache.professoriContainer.innerHTML = '';

            const fragment = document.createDocumentFragment();

            matches.forEach((m, idx) => {
                const card = document.createElement('div');
                card.className = 'match-card fade-in-el';
                card.style.animationDelay = (idx * 0.1) + 's';

                const isPlayed = !!m.risultato;
                let scoreA = isPlayed ? m.gol_a : '-';
                let scoreB = isPlayed ? m.gol_b : '-';

                // Cerca i loghi, con fallback specifici per Juve e Milan se mancano
                const logoA = getLogo(m.squadra_a) || (m.squadra_a.toLowerCase().includes('juve') ? 'assets/logos/juventus.png' : '');
                const logoB = getLogo(m.squadra_b) || (m.squadra_b.toLowerCase().includes('milan') ? 'assets/logos/milan.png' : '');

                // Determina chi ha vinto per evidenziarlo
                let classA = '', classB = '';
                if (isPlayed) {
                    if (m.risultato === 'rigori_a') {
                        classA = 'winner';
                    } else if (m.risultato === 'rigori_b') {
                        classB = 'winner';
                    } else if (parseInt(m.gol_a) > parseInt(m.gol_b)) {
                        classA = 'winner';
                    } else if (parseInt(m.gol_b) > parseInt(m.gol_a)) {
                        classB = 'winner';
                    }
                }

                // Genera l'HTML della partita
                card.innerHTML = `
                    <div class="match-meta">
                        <span class="match-day">${m.giornata || 'Speciale'}</span>
                        <span class="match-status ${isPlayed ? 'play-status' : 'status-upcoming'}">${isPlayed ? 'Terminata' : 'Da Giocare'}</span>
                    </div>
                    <div class="match-row ${classA}">
                        <div style="display:flex; align-items:center; gap:10px;">
                            ${logoA ? `<img src="${logoA}" class="team-logo-small" alt="">` : ''}
                            <span>${m.squadra_a}</span>
                        </div>
                        <div class="score-box">${scoreA}</div>
                    </div>
                    <div class="match-row ${classB}">
                         <div style="display:flex; align-items:center; gap:10px;">
                            ${logoB ? `<img src="${logoB}" class="team-logo-small" alt="" onerror="this.style.display='none'">` : ''}
                            <span>${m.squadra_b}</span>
                        </div>
                        <div class="score-box">${scoreB}</div>
                    </div>
                    ${(m.note) ? `<div style="font-size:0.75rem; text-align:right; color:var(--text-muted); margin-top:0.5rem; font-style:italic">${m.note}</div>` : ''}
                `;
                fragment.appendChild(card);
            });

            domCache.professoriContainer.appendChild(fragment);
        }

        // Disegna il calendario delle partite del torneo
        function renderMatches(matches) {
            domCache.matchesContainer.innerHTML = '';

            // Raggruppa le partite per giornata (Giornata 1, Giornata 2, ecc.)
            const grouped = {};
            matches.forEach(m => {
                const g = m.giornata || "Altro";
                if (!grouped[g]) grouped[g] = [];
                grouped[g].push(m);
            });

            // Ordina le giornate numericamente
            const keys = Object.keys(grouped).sort((a, b) => {
                const na = parseInt(a);
                const nb = parseInt(b);
                if (!isNaN(na) && !isNaN(nb)) return na - nb;
                return a.toString().localeCompare(b.toString());
            });

            const fragment = document.createDocumentFragment();

            keys.forEach((dayKey, grpIdx) => {
                // Crea il contenitore per la giornata
                const groupDiv = document.createElement('div');
                groupDiv.className = 'match-day-group fade-in-el';
                groupDiv.style.animationDelay = (grpIdx * 0.1) + 's';

                // Titolo della giornata
                const title = document.createElement('div');
                title.className = 'match-day-title';
                title.textContent = isNaN(dayKey) ? dayKey : `Giornata ${dayKey}`;
                groupDiv.appendChild(title);

                const grid = document.createElement('div');
                grid.className = 'matches-grid';

                // Cicla su tutte le partite della giornata
                grouped[dayKey].forEach((m) => {
                    const card = document.createElement('div');
                    card.className = 'match-card';

                    const isPlayed = !!m.risultato;
                    let scoreA = isPlayed ? m.gol_a : '-';
                    let scoreB = isPlayed ? m.gol_b : '-';
                    const logoA = getLogo(m.squadra_a);
                    const logoB = getLogo(m.squadra_b);

                    // Calcola chi ha vinto
                    let classA = '', classB = '';
                    if (isPlayed) {
                        if (parseInt(m.gol_a) > parseInt(m.gol_b)) classA = 'winner';
                        else if (parseInt(m.gol_b) > parseInt(m.gol_a)) classB = 'winner';
                        else {
                            if (m.risultato === 'rigori_a') classA = 'winner';
                            if (m.risultato === 'rigori_b') classB = 'winner';
                        }
                    }

                    // HTML della card partita
                    card.innerHTML = `
                        <div class="match-meta">
                            <span>#${m.id}</span>
                            <span class="match-status ${isPlayed ? 'play-status' : 'status-upcoming'}">${isPlayed ? 'Terminata' : 'Da Giocare'}</span>
                        </div>
                        <div class="match-row ${classA}">
                            <div style="display:flex; align-items:center; gap:10px;">
                                ${logoA ? `<img src="${logoA}" style="width:24px;height:24px;object-fit:contain;" alt="">` : ''}
                                <span>${m.squadra_a}</span>
                            </div>
                            <span class="score-box">${scoreA}</span>
                        </div>
                        <div class="match-row ${classB}">
                             <div style="display:flex; align-items:center; gap:10px;">
                                ${logoB ? `<img src="${logoB}" style="width:24px;height:24px;object-fit:contain;" alt="">` : ''}
                                <span>${m.squadra_b}</span>
                            </div>
                            <span class="score-box">${scoreB}</span>
                        </div>
                        ${(m.risultato && m.risultato.includes('rigori')) ? '<div style="font-size:0.75rem; text-align:right; color:var(--text-muted); margin-top:0.5rem; font-style:italic">Vittoria ai rigori</div>' : ''}
                    `;
                    grid.appendChild(card);
                });

                groupDiv.appendChild(grid);
                fragment.appendChild(groupDiv);
            });

            domCache.matchesContainer.appendChild(fragment);
        }

        // --- PARTICLES & EPIC BACKGROUND ---
        // Gestisce l'effetto particellare (polvere d'oro) sullo sfondo
        function initParticles() {
            const canvas = document.getElementById('particle-canvas');
            if (!canvas) return; // Se non c'√® il canvas, esce
            const ctx = canvas.getContext('2d');

            let particlesArray = [];

            // Adatta il canvas alla dimensione dello schermo
            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }

            // Debounce resize
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    resize();
                    createParticles();
                }, 100);
            });
            resize();

            // Classe che definisce una singola particella
            class Particle {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.size = Math.random() * 2 + 0.1; // Dimensione variabile
                    this.speedX = (Math.random() * 0.5) - 0.25; // Velocit√† orizzontale
                    this.speedY = (Math.random() * 0.5) - 0.25; // Velocit√† verticale
                    this.opacity = Math.random() * 0.5 + 0.1; // Trasparenza
                    this.color = `rgba(251, 191, 36, ${this.opacity})`; // Colore oro
                }
                // Aggiorna la posizione
                update() {
                    this.x += this.speedX;
                    this.y += this.speedY;

                    // Se esce dallo schermo, riappare dal lato opposto
                    if (this.x > canvas.width) this.x = 0;
                    if (this.x < 0) this.x = canvas.width;
                    if (this.y > canvas.height) this.y = 0;
                    if (this.y < 0) this.y = canvas.height;
                }
                // Disegna la particella
                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();

                    // Se √® grande, aggiungi un alone luminoso
                    if (this.size > 1.5) {
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = "rgba(251, 191, 36, 0.5)";
                    } else {
                        ctx.shadowBlur = 0;
                    }
                }
            }

            // Crea tutte le particelle
            function createParticles() {
                particlesArray = [];
                // Numero particelle in base alla grandezza schermo (densit√† costante)
                const numberOfParticles = (canvas.width * canvas.height) / 10000;
                for (let i = 0; i < numberOfParticles; i++) {
                    particlesArray.push(new Particle());
                }
            }

            // Loop di animazione che gira continuamente
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Pulisce il frame precedente
                for (let i = 0; i < particlesArray.length; i++) {
                    particlesArray[i].update(); // Muove
                    particlesArray[i].draw();   // Disegna
                }
                requestAnimationFrame(animate); // Richiede il prossimo frame
            }

            createParticles();
            animate();
        }

        // Quando la pagina ha finito di caricare, avvia tutto
        window.addEventListener('load', () => {
            fetchData();
            initParticles();
        });
    </script>
</body>

</html>